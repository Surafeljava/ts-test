name: Start TestSavant Run (Webhook)

permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      redteaming_id:
        description: "Red-Teaming config UUID"
        required: true
      callback_urls:
        description: "Comma-separated webhook URLs (preferred)"
        required: false
      callback_url:
        description: "Public webhook receiver URL (https://...)"
        required: false
      strict:
        description: "Strict gate (1/0)"
        required: false
        default: "1"
      max_vuln_rate:
        description: "Max vulnerability rate (e.g., 0.10)"
        required: false
        default: ""
      timeout:
        description: "Timeout seconds"
        required: false
        default: "3600"

jobs:
  start:
    runs-on: ubuntu-latest
    env:
      TESTSAVANT_API_KEY: ${{ secrets.TESTSAVANT_API_KEY }}
      TS_GITHUB_TOKEN: ${{ secrets.TS_GITHUB_TOKEN }}
      # Optional gating controls
      TS_STRICT: ${{ vars.TS_STRICT }}
      MAX_VULN_RATE: ${{ vars.MAX_VULN_RATE }}
      MAX_VULN_COUNT: ${{ vars.MAX_VULN_COUNT }}
      POLL_TIMEOUT: ${{ vars.TS_POLL_TIMEOUT }}
      DISPATCH_EVENT: testsavant_poll_passed
    steps:
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install SDK from repository (token)
        run: |
          python -m pip install --upgrade pip
          python -m pip install "git+https://${TS_GITHUB_TOKEN}@github.com/TestSavantAI/testsavant-redteam"

      - name: Start run via webhook callback
        id: start_run
        run: |
          python - <<'PY'
          import os, sys, json
          from testsavant_redteaming.client import TestSavantClient
          api_key = os.environ.get('TESTSAVANT_API_KEY')
          if not api_key:
            print('Missing TESTSAVANT_API_KEY secret', file=sys.stderr)
            sys.exit(2)
          red_id = '${{ inputs.redteaming_id }}'
          cb_urls = '${{ inputs.callback_urls }}'.strip()
          cb_url = '${{ inputs.callback_url }}'.strip()
          callback_urls = cb_urls or cb_url
          if not callback_urls:
            print('Provide callback_urls (preferred) or callback_url', file=sys.stderr)
            sys.exit(2)
          client = TestSavantClient(api_key=api_key)
          run_id = client.create_run(red_id, callback_urls=callback_urls, callback_events='run.completed,run.failed')
          print(json.dumps({'run_id': run_id}))
          # Expose run_id for later steps
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"run_id={run_id}\n")
          PY

      - name: Poll for completion and gate
        id: poll_and_gate
        env:
          RUN_ID: ${{ steps.start_run.outputs.run_id }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          python - <<'PY'
          import os, sys, json
          import requests
          from testsavant_redteaming.client import TestSavantClient
          from testsavant_redteaming.utils import wait_for_completion, check_gate

          api_key = os.environ.get('TESTSAVANT_API_KEY')
          run_id = os.environ.get('RUN_ID')
          timeout = int(os.environ.get('POLL_TIMEOUT') or '3600')
          strict_env = (os.environ.get('TS_STRICT') or '1').strip()
          strict = strict_env not in ('0', 'false', 'False', '')
          max_rate = os.environ.get('MAX_VULN_RATE')
          max_rate = float(max_rate) if (max_rate or '').strip() not in ('', 'None') else None
          max_count = os.environ.get('MAX_VULN_COUNT')
          max_count = int(max_count) if (max_count or '').strip() not in ('', 'None') else None

          if not api_key or not run_id:
            print('Missing TESTSAVANT_API_KEY or RUN_ID', file=sys.stderr)
            sys.exit(2)

          client = TestSavantClient(api_key=api_key)
          try:
            result = wait_for_completion(client, run_id, timeout=timeout, interval=15)
          except TimeoutError:
            print('Polling timed out', file=sys.stderr)
            sys.exit(2)

          print(json.dumps(result))
          allowed = check_gate(
            result,
            strict=strict,
            max_vulnerability_rate=max_rate,
            max_vulnerable_count=max_count,
          )
          # Output for subsequent steps
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"proceed={'true' if allowed else 'false'}\n")

          if allowed:
            # Trigger next workflow via repository_dispatch
            repo = os.environ.get('GITHUB_REPOSITORY')
            token = os.environ.get('GITHUB_TOKEN')
            event_type = os.environ.get('DISPATCH_EVENT', 'testsavant_poll_passed')
            url = f"https://api.github.com/repos/{repo}/dispatches"
            headers = {"Authorization": f"token {token}", "Accept": "application/vnd.github+json"}
            payload = {"event_type": event_type, "client_payload": {"run_id": run_id, "result": result}}
            r = requests.post(url, headers=headers, json=payload, timeout=15)
            if r.status_code >= 300:
              print(f"Failed to dispatch next workflow: {r.status_code} {r.text}", file=sys.stderr)
              sys.exit(1)
          PY

      - name: Proceeding...
        if: steps.poll_and_gate.outputs.proceed == 'true'
        run: echo "Proceeding with next steps (dispatched testsavant_poll_passed)."

      - name: Halting due to gate
        if: steps.poll_and_gate.outputs.proceed != 'true'
        run: echo "Halting because gate conditions not met."

# Notes:
# - This workflow only starts a run with a webhook callback. The receiver should forward
#   events to GitHub via repository_dispatch (testsavant_run_completed), which this repo
#   handles in `.github/workflows/on-dispatch.yml`.
# - Set `TESTSAVANT_API_KEY` in repo secrets, and provide `callback_urls` (comma-separated) or a single `callback_url`.
