name: Start TestSavant Run on Push

on:
  push:
    branches: [main]

permissions:
  contents: write

jobs:
  start:
    runs-on: ubuntu-latest
    env:
      TESTSAVANT_API_KEY: ${{ secrets.TESTSAVANT_API_KEY }}
      REDTEAMING_ID: ${{ vars.REDTEAMING_ID }}
      RECEIVER_WEBHOOK_URLS: ${{ secrets.RECEIVER_WEBHOOK_URLS }}
      RECEIVER_WEBHOOK_URL: ${{ secrets.RECEIVER_WEBHOOK_URL }}
      TS_GITHUB_TOKEN: ${{ secrets.TS_GITHUB_TOKEN }}
      # Optional gating controls
      TS_STRICT: ${{ vars.TS_STRICT }}
      MAX_VULN_RATE: ${{ vars.MAX_VULN_RATE }}
      MAX_VULN_COUNT: ${{ vars.MAX_VULN_COUNT }}
      POLL_TIMEOUT: ${{ vars.TS_POLL_TIMEOUT }}
      DISPATCH_EVENT: testsavant_poll_passed
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install SDK from repository (token)
        run: |
          python -m pip install --upgrade pip
          python -m pip install "git+https://${TS_GITHUB_TOKEN}@github.com/TestSavantAI/testsavant-redteam"

      - name: Start run via multiple webhook callbacks
        id: start_run
        run: |
          python - <<'PY'
          import os, sys, json
          from testsavant_redteaming.client import TestSavantClient

          api_key = os.environ.get('TESTSAVANT_API_KEY')
          red_id = os.environ.get('REDTEAMING_ID')
          cb_urls = os.environ.get('RECEIVER_WEBHOOK_URLS') or ''
          cb_url = os.environ.get('RECEIVER_WEBHOOK_URL') or ''
          # Prefer list env; fallback to single
          callback_urls = cb_urls.strip() or cb_url.strip()

          missing = [k for k,v in [('TESTSAVANT_API_KEY', api_key), ('REDTEAMING_ID', red_id)] if not v]
          if not callback_urls:
            missing.append('RECEIVER_WEBHOOK_URLS or RECEIVER_WEBHOOK_URL')
          if missing:
            print(f"Missing required envs: {', '.join(missing)}", file=sys.stderr)
            sys.exit(2)

          client = TestSavantClient(api_key=api_key)
          run_id = client.create_run(red_id, callback_urls=callback_urls, callback_events='run.completed,run.failed')
          print(json.dumps({'run_id': run_id}))
          # Expose run_id for later steps
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"run_id={run_id}\n")
          PY

      - name: Poll for completion and gate
        id: poll_and_gate
        env:
          RUN_ID: ${{ steps.start_run.outputs.run_id }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          python - <<'PY'
          import os, sys, json, time
          import requests
          from testsavant_redteaming.client import TestSavantClient
          from testsavant_redteaming.utils import wait_for_completion, check_gate

          api_key = os.environ.get('TESTSAVANT_API_KEY')
          run_id = os.environ.get('RUN_ID')
          timeout = int(os.environ.get('POLL_TIMEOUT') or '3600')
          strict_env = (os.environ.get('TS_STRICT') or '1').strip()
          strict = strict_env not in ('0', 'false', 'False', '')
          max_rate = os.environ.get('MAX_VULN_RATE')
          max_rate = float(max_rate) if (max_rate or '').strip() not in ('', 'None') else None
          max_count = os.environ.get('MAX_VULN_COUNT')
          max_count = int(max_count) if (max_count or '').strip() not in ('', 'None') else None

          if not api_key or not run_id:
            print('Missing TESTSAVANT_API_KEY or RUN_ID', file=sys.stderr)
            sys.exit(2)

          client = TestSavantClient(api_key=api_key)
          try:
            result = wait_for_completion(client, run_id, timeout=timeout, interval=15)
          except TimeoutError:
            print('Polling timed out', file=sys.stderr)
            sys.exit(2)

          print(json.dumps(result))
          allowed = check_gate(
            result,
            strict=strict,
            max_vulnerability_rate=max_rate,
            max_vulnerable_count=max_count,
          )
          # Output for subsequent steps
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"proceed={'true' if allowed else 'false'}\n")

          if allowed:
            repo = os.environ.get('GITHUB_REPOSITORY')
            token = os.environ.get('GITHUB_TOKEN')
            event_type = os.environ.get('DISPATCH_EVENT', 'testsavant_poll_passed')
            url = f"https://api.github.com/repos/{repo}/dispatches"
            headers = {"Authorization": f"token {token}", "Accept": "application/vnd.github+json"}
            payload = {"event_type": event_type, "client_payload": {"run_id": run_id, "result": result}}
            r = requests.post(url, headers=headers, json=payload, timeout=15)
            if r.status_code >= 300:
              print(f"Failed to dispatch next workflow: {r.status_code} {r.text}", file=sys.stderr)
              sys.exit(1)
          PY

      - name: Proceeding...
        if: steps.poll_and_gate.outputs.proceed == 'true'
        run: echo "Proceeding with next steps (dispatched testsavant_poll_passed)."

      - name: Halting due to gate
        if: steps.poll_and_gate.outputs.proceed != 'true'
        run: echo "Halting because gate conditions not met."

# Notes:
# - Set repo secret `TESTSAVANT_API_KEY` and either `RECEIVER_WEBHOOK_URLS` (comma-separated) or `RECEIVER_WEBHOOK_URL` (single) pointing to public HTTPS receivers.
# - Set repo variable `REDTEAMING_ID` (UUID). Optionally set `TESTSAVANT_BASE_URL`.
# - Your webhook receiver should trigger `repository_dispatch` on final events, which
#   this repo handles in `.github/workflows/on-dispatch.yml`.

